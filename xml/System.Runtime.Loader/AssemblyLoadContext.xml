<Type Name="AssemblyLoadContext" FullName="System.Runtime.Loader.AssemblyLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7d48bdcd93c7e80b6d4e620d0088b451acac8922" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73389487" /></Metadata><TypeSignature Language="C#" Value="public abstract class AssemblyLoadContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AssemblyLoadContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Loader.AssemblyLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AssemblyLoadContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyLoadContext abstract" />
  <TypeSignature Language="F#" Value="type AssemblyLoadContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Loader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="6e651-101">表示程序集加载范围的运行时概念。</span><span class="sxs-lookup"><span data-stu-id="6e651-101">Represents the runtime's concept of a scope for assembly loading.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="6e651-102"><xref:System.Runtime.Loader.AssemblyLoadContext> 表示加载上下文。</span><span class="sxs-lookup"><span data-stu-id="6e651-102">The <xref:System.Runtime.Loader.AssemblyLoadContext> represents a load context.</span></span> <span data-ttu-id="6e651-103">从概念上讲，加载上下文创建用于加载、解析和可能卸载一组程序集的作用域。</span><span class="sxs-lookup"><span data-stu-id="6e651-103">Conceptually, a load context creates a scope for loading, resolving, and potentially unloading a set of assemblies.</span></span>
 
 <span data-ttu-id="6e651-104"><xref:System.Runtime.Loader.AssemblyLoadContext> 是一个抽象类。</span><span class="sxs-lookup"><span data-stu-id="6e651-104"><xref:System.Runtime.Loader.AssemblyLoadContext> is an abstract class.</span></span> <span data-ttu-id="6e651-105">需要实现 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> 才能创建具体的类。</span><span class="sxs-lookup"><span data-stu-id="6e651-105">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> needs to be implemented to create a concrete class.</span></span>
 
 <span data-ttu-id="6e651-106"><xref:System.Runtime.Loader.AssemblyLoadContext> 存在主要用于提供程序集加载隔离。</span><span class="sxs-lookup"><span data-stu-id="6e651-106">The <xref:System.Runtime.Loader.AssemblyLoadContext> exists primarily to provide assembly loading isolation.</span></span> <span data-ttu-id="6e651-107">它允许在单个进程中加载同一程序集的多个版本。</span><span class="sxs-lookup"><span data-stu-id="6e651-107">It allows multiple versions of the same assembly to be loaded within a single process.</span></span> <span data-ttu-id="6e651-108">它取代了 .NET Framework 中多个 <xref:System.AppDomain> 实例提供的隔离机制。</span><span class="sxs-lookup"><span data-stu-id="6e651-108">It replaces the isolation mechanisms provided by multiple <xref:System.AppDomain> instances in the .NET Framework.</span></span>
 
 > [!NOTE]
 > <span data-ttu-id="6e651-109"><xref:System.Runtime.Loader.AssemblyLoadContext> 不提供任何安全功能。</span><span class="sxs-lookup"><span data-stu-id="6e651-109"><xref:System.Runtime.Loader.AssemblyLoadContext> does not provide any security features.</span></span> <span data-ttu-id="6e651-110">所有代码都具有该进程的完全权限。</span><span class="sxs-lookup"><span data-stu-id="6e651-110">All code has full permissions of the process.</span></span>

### <a name="usage-in-the-runtime"></a><span data-ttu-id="6e651-111">运行时中的用法</span><span class="sxs-lookup"><span data-stu-id="6e651-111">Usage in the runtime</span></span>
 <span data-ttu-id="6e651-112">运行时实现了两个程序集加载上下文：</span><span class="sxs-lookup"><span data-stu-id="6e651-112">The runtime implements two assembly load contexts:</span></span>
 * <span data-ttu-id="6e651-113"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 表示运行时用于应用程序主程序集及其静态依赖项的默认上下文。</span><span class="sxs-lookup"><span data-stu-id="6e651-113"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> represents the runtime's default context which is used for the application main assembly and its static dependencies.</span></span>
 * <span data-ttu-id="6e651-114"><xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType> 方法通过实例化最基本的 <xref:System.Runtime.Loader.AssemblyLoadContext>来隔离它加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-114">The <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType> method isolates the assemblies it loads by instantiating the most basic <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="6e651-115">它有一种简化的隔离方案，该方案将每个程序集加载到自己的 <xref:System.Runtime.Loader.AssemblyLoadContext> 中，无需依赖关系。</span><span class="sxs-lookup"><span data-stu-id="6e651-115">It has a simplistic isolation scheme which loads each assembly in its own <xref:System.Runtime.Loader.AssemblyLoadContext> with no dependency resolution.</span></span>
 
### <a name="application-usage"></a><span data-ttu-id="6e651-116">应用程序使用情况</span><span class="sxs-lookup"><span data-stu-id="6e651-116">Application usage</span></span>
 <span data-ttu-id="6e651-117">应用程序可以创建自己的 <xref:System.Runtime.Loader.AssemblyLoadContext>，为高级方案创建自定义解决方案。</span><span class="sxs-lookup"><span data-stu-id="6e651-117">An application can create its own <xref:System.Runtime.Loader.AssemblyLoadContext> to create a custom solution for advanced scenarios.</span></span> <span data-ttu-id="6e651-118">自定义重点介绍如何定义依赖项解析机制。</span><span class="sxs-lookup"><span data-stu-id="6e651-118">The customization focuses on defining dependency resolution mechanisms.</span></span>
 
 <span data-ttu-id="6e651-119"><xref:System.Runtime.Loader.AssemblyLoadContext> 提供了两个扩展点来实现托管程序集解析：</span><span class="sxs-lookup"><span data-stu-id="6e651-119">The <xref:System.Runtime.Loader.AssemblyLoadContext> provides two extension points to implement managed assembly resolution:</span></span>
 1. <span data-ttu-id="6e651-120"><xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> 提供 <xref:System.Runtime.Loader.AssemblyLoadContext> 解析程序集、加载和返回程序集的第一种机会。</span><span class="sxs-lookup"><span data-stu-id="6e651-120">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> provides the first chance for the <xref:System.Runtime.Loader.AssemblyLoadContext> to resolve the assembly, load it and return it.</span></span> <span data-ttu-id="6e651-121">如果 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> 返回 `null`，加载程序将尝试将程序集加载到 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6e651-121">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> returns `null`, the loader will try to load the assembly into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span>
 2. <span data-ttu-id="6e651-122">如果 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 无法解析程序集，则原始 <xref:System.Runtime.Loader.AssemblyLoadContext> 会获得另一个机会来解析程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-122">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> is unable to resolve the assembly, the original <xref:System.Runtime.Loader.AssemblyLoadContext> gets a second chance to resolve the assembly.</span></span> <span data-ttu-id="6e651-123">运行时引发 <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> 事件。</span><span class="sxs-lookup"><span data-stu-id="6e651-123">The runtime raises the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.</span></span>
 
 <span data-ttu-id="6e651-124">此外，<xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType> 虚方法还允许自定义默认的非托管程序集解析。</span><span class="sxs-lookup"><span data-stu-id="6e651-124">Additionally the <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType> virtual method allows customization of the default unmanaged assembly resolution.</span></span> <span data-ttu-id="6e651-125">默认实现返回 `null`，这会使运行时搜索使用其默认搜索策略，这对大多数方案都足够了。</span><span class="sxs-lookup"><span data-stu-id="6e651-125">The default implementation returns `null`, which causes the runtime search to use its default search policy which is sufficient for most scenarios.</span></span>

### <a name="technical-challenges"></a><span data-ttu-id="6e651-126">技术挑战</span><span class="sxs-lookup"><span data-stu-id="6e651-126">Technical challenges</span></span>
 * <span data-ttu-id="6e651-127">不能在一个进程中加载多个版本的运行时。</span><span class="sxs-lookup"><span data-stu-id="6e651-127">It is not possible to load multiple versions of the runtime in a single process.</span></span>
     > [!CAUTION]
     > <span data-ttu-id="6e651-128">加载多个副本或不同版本的 framework 程序集可能会导致意外的和难以诊断的行为。</span><span class="sxs-lookup"><span data-stu-id="6e651-128">Loading multiple copies or different versions of framework assemblies can lead to unexpected and hard to diagnose behavior.</span></span>
     
     > [!TIP]
     > <span data-ttu-id="6e651-129">通过远程处理和/或进程间通信使用处理边界来解决此隔离问题。</span><span class="sxs-lookup"><span data-stu-id="6e651-129">Use process boundaries with remoting and/or interprocess communication to solve this isolation problem.</span></span>
 
 * <span data-ttu-id="6e651-130">程序集加载的时间可能会使测试和调试变得困难。</span><span class="sxs-lookup"><span data-stu-id="6e651-130">The timing of assembly loading can make testing and debugging difficult.</span></span> <span data-ttu-id="6e651-131">通常会加载程序集，而不会立即解析其依赖项。</span><span class="sxs-lookup"><span data-stu-id="6e651-131">Assemblies are typically loaded without their dependencies immediately being resolved.</span></span> <span data-ttu-id="6e651-132">依赖项在需要时加载：</span><span class="sxs-lookup"><span data-stu-id="6e651-132">The dependencies are loaded as they are needed:</span></span>
     * <span data-ttu-id="6e651-133">当代码分支到依赖程序集时。</span><span class="sxs-lookup"><span data-stu-id="6e651-133">When code branches into a dependent assembly.</span></span>
     * <span data-ttu-id="6e651-134">当代码加载资源时。</span><span class="sxs-lookup"><span data-stu-id="6e651-134">When code loads resources.</span></span>
     * <span data-ttu-id="6e651-135">当代码显式加载程序集时。</span><span class="sxs-lookup"><span data-stu-id="6e651-135">When code explicitly loads assemblies.</span></span>
 
 * <span data-ttu-id="6e651-136"><xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> 的实现可能会添加新的依赖项，这可能需要进行隔离才能存在不同的版本。</span><span class="sxs-lookup"><span data-stu-id="6e651-136">The implementation of <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> can add new dependencies which may need to be isolated to allow different versions to exist.</span></span> <span data-ttu-id="6e651-137">最自然的实现会将这些依赖项置于默认上下文中。</span><span class="sxs-lookup"><span data-stu-id="6e651-137">The most natural implementation would place these dependencies in the default context.</span></span> <span data-ttu-id="6e651-138">仔细设计可以隔离新的依赖项。</span><span class="sxs-lookup"><span data-stu-id="6e651-138">Careful design can isolate the new dependencies.</span></span>
 
 * <span data-ttu-id="6e651-139">同一程序集多次加载到不同的上下文中。</span><span class="sxs-lookup"><span data-stu-id="6e651-139">The same assembly is loaded multiple times into different contexts.</span></span>
     * <span data-ttu-id="6e651-140">这可能会导致混淆错误消息，例如 "无法将类型 ' 插件的对象强制转换为类型 ' 插件"。</span><span class="sxs-lookup"><span data-stu-id="6e651-140">This can lead to confusing error messages, for example "Unable to cast object of type 'Sample.Plugin' to type 'Sample.Plugin'."</span></span>
     * <span data-ttu-id="6e651-141">跨隔离边界进行的封送处理是非常重要的。</span><span class="sxs-lookup"><span data-stu-id="6e651-141">Marshaling across isolation boundaries is non-trivial.</span></span> <span data-ttu-id="6e651-142">典型的解决方案是使用在程序集中定义的接口，该接口仅加载到默认加载上下文中。</span><span class="sxs-lookup"><span data-stu-id="6e651-142">A typical solution would be to use an interface defined in an assembly which is only loaded into the default load context.</span></span>
 
 ]]></format>
    </remarks>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md"><span data-ttu-id="6e651-143">AssemblyLoadContext CoreCLR 设计文档</span><span class="sxs-lookup"><span data-stu-id="6e651-143">AssemblyLoadContext CoreCLR design document</span></span></related>
    <related type="Article" href="~/docs/standard/assembly/unloadability.md"><span data-ttu-id="6e651-144">如何在 .NET Core 中使用和调试程序集可卸载性</span><span class="sxs-lookup"><span data-stu-id="6e651-144">How to use and debug assembly unloadability in .NET Core</span></span></related>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/unloadability.md"><span data-ttu-id="6e651-145">AssemblyLoadContext unloadability 设计文档</span><span class="sxs-lookup"><span data-stu-id="6e651-145">AssemblyLoadContext unloadability design document</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6e651-146">初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="6e651-146">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="6e651-147">此构造函数受到保护。</span><span class="sxs-lookup"><span data-stu-id="6e651-147">This constructor is protected.</span></span> <span data-ttu-id="6e651-148">它只能从 <xref:System.Runtime.Loader.AssemblyLoadContext> 类或其派生类中调用。</span><span class="sxs-lookup"><span data-stu-id="6e651-148">It can only be called from the <xref:System.Runtime.Loader.AssemblyLoadContext> class or its derived classes.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext (bool isCollectible);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (isCollectible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext(bool isCollectible);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext isCollectible" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isCollectible" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isCollectible"><span data-ttu-id="6e651-149">要启用 <see cref="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-149"><see langword="true" /> to enable <see cref="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="6e651-150">默认值为 <see langword="false" />，因为启用卸载会产生性能成本。</span><span class="sxs-lookup"><span data-stu-id="6e651-150">The default value is <see langword="false" /> because there is a performance cost associated with enabling unloading.</span></span></param>
        <summary><span data-ttu-id="6e651-151">使用一个指示是否启用卸载的值来初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="6e651-151">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class with a value that indicates whether unloading is enabled.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="6e651-152">此构造函数受到保护。</span><span class="sxs-lookup"><span data-stu-id="6e651-152">This constructor is protected.</span></span> <span data-ttu-id="6e651-153">它只能从 <xref:System.Runtime.Loader.AssemblyLoadContext> 类或其派生类中调用。</span><span class="sxs-lookup"><span data-stu-id="6e651-153">It can only be called from the <xref:System.Runtime.Loader.AssemblyLoadContext> class or its derived classes.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyLoadContext (string name, bool isCollectible = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional isCollectible As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : string * bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext (name, isCollectible)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="isCollectible" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6e651-154">新实例中 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.Name" /> 的值。</span><span class="sxs-lookup"><span data-stu-id="6e651-154">The value for <see cref="P:System.Runtime.Loader.AssemblyLoadContext.Name" /> in the new instance.</span></span> <span data-ttu-id="6e651-155">其值可为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-155">Its value can be <see langword="null" />.</span></span></param>
        <param name="isCollectible"><span data-ttu-id="6e651-156">要启用 <see cref="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-156"><see langword="true" /> to enable <see cref="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="6e651-157">默认值为 <see langword="false" />，因为启用卸载会产生性能成本。</span><span class="sxs-lookup"><span data-stu-id="6e651-157">The default value is <see langword="false" /> because there is a performance cost associated with enabling unloading.</span></span></param>
        <summary><span data-ttu-id="6e651-158">使用名称和指示是否启用卸载的值来初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="6e651-158">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class with a name and a value that indicates whether unloading is enabled.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt; All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IEnumerable`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; All" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property All As IEnumerable(Of AssemblyLoadContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ All { System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : seq&lt;System.Runtime.Loader.AssemblyLoadContext&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e651-159">返回一个包含所有 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 实例的集合。</span><span class="sxs-lookup"><span data-stu-id="6e651-159">Returns a collection of all <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> instances.</span></span></summary>
        <value><span data-ttu-id="6e651-160">所有 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 实例的集合。</span><span class="sxs-lookup"><span data-stu-id="6e651-160">A collection of all <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> instances.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; Assemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; Assemblies" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Assemblies As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ Assemblies { System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assemblies : seq&lt;System.Reflection.Assembly&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e651-161">返回一个集合，它包含在 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 中加载的 <see cref="T:System.Reflection.Assembly" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="6e651-161">Returns a collection of the <see cref="T:System.Reflection.Assembly" /> instances loaded in the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <value><span data-ttu-id="6e651-162"><see cref="T:System.Runtime.Loader.AssemblyLoadContext" />中加载的 <see cref="T:System.Reflection.Assembly" /> 实例的集合。</span><span class="sxs-lookup"><span data-stu-id="6e651-162">A collection of the <see cref="T:System.Reflection.Assembly" /> instances loaded in the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentContextualReflectionContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContextualReflectionContext As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ CurrentContextualReflectionContext { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContextualReflectionContext : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e651-163">获取由最近调用 <see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" /> 而设置的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-163">Gets the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> set by the most recent call to <see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />.</span></span></summary>
        <value><span data-ttu-id="6e651-164">由最近对 <see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />的调用设置的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-164">The <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> set by the most recent call to <see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />.</span></span> <span data-ttu-id="6e651-165">此值可为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-165">This value can be <see langword="null" />.</span></span> <span data-ttu-id="6e651-166">值存储在 <see cref="T:System.Threading.AsyncLocal`1" /> 中，因此该值对于每个异步上下文都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="6e651-166">The value is stored in an <see cref="T:System.Threading.AsyncLocal`1" />, so the value is unique per asynchronous context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="6e651-167">有关详细信息，请参阅[AssemblyLoadContext. CurrentContextualReflectionContext design doc in .Net Core](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md)。</span><span class="sxs-lookup"><span data-stu-id="6e651-167">For more information, see [AssemblyLoadContext.CurrentContextualReflectionContext design doc in .NET Core](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ Default { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e651-168">获取默认的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-168">Gets the default <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span> <span data-ttu-id="6e651-169">默认上下文包含主应用程序程序集及其静态依赖项。</span><span class="sxs-lookup"><span data-stu-id="6e651-169">The default context contains the main application assembly and its static dependencies.</span></span></summary>
        <value><span data-ttu-id="6e651-170">默认程序集加载上下文。</span><span class="sxs-lookup"><span data-stu-id="6e651-170">The default assembly load context.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />
      <MemberSignature Language="VB.NET" Value="Public Function EnterContextualReflection () As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection();" />
      <MemberSignature Language="F#" Value="member this.EnterContextualReflection : unit -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="assemblyLoadContext.EnterContextualReflection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6e651-171">将 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> 设置为 <see langword="this" /><see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-171">Sets <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> to <see langword="this" /><see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <returns><span data-ttu-id="6e651-172">一个对象，它用于还原 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> 的先前值。</span><span class="sxs-lookup"><span data-stu-id="6e651-172">An object to restore the previous value of <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />.</span></span> <span data-ttu-id="6e651-173">它将作为 <see cref="T:System.IDisposable" /> 在 <see langword="using" /> 块中使用。</span><span class="sxs-lookup"><span data-stu-id="6e651-173">It is intended to be used as an <see cref="T:System.IDisposable" /> in a <see langword="using" /> block.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="6e651-174">有关详细信息，请参阅[AssemblyLoadContext. CurrentContextualReflectionContext design doc in .Net Core](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md)。</span><span class="sxs-lookup"><span data-stu-id="6e651-174">For more information, see [AssemblyLoadContext.CurrentContextualReflectionContext design doc in .NET Core](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection (System.Reflection.Assembly activating);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection(class System.Reflection.Assembly activating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnterContextualReflection (activating As Assembly) As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection(System::Reflection::Assembly ^ activating);" />
      <MemberSignature Language="F#" Value="static member EnterContextualReflection : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection activating" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activating" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activating"><span data-ttu-id="6e651-175">用于确定请求的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 实例的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-175">The assembly that is used to determine the requested <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> instance.</span></span></param>
        <summary><span data-ttu-id="6e651-176">将 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> 设置为加载了程序集的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-176">Sets <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> to the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> which loaded the assembly.</span></span></summary>
        <returns><span data-ttu-id="6e651-177">一个对象，它用于还原 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> 的先前值。</span><span class="sxs-lookup"><span data-stu-id="6e651-177">An object to restore the previous value of <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />.</span></span> <span data-ttu-id="6e651-178">它将作为 <see cref="T:System.IDisposable" /> 在 <see langword="using" /> 块中使用。</span><span class="sxs-lookup"><span data-stu-id="6e651-178">It is intended to be used as an <see cref="T:System.IDisposable" /> in a <see langword="using" /> block.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="6e651-179">有关详细信息，请参阅[AssemblyLoadContext. CurrentContextualReflectionContext design doc in .Net Core](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md)。</span><span class="sxs-lookup"><span data-stu-id="6e651-179">For more information, see [AssemblyLoadContext.CurrentContextualReflectionContext design doc in .NET Core](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!AssemblyLoadContext ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="assemblyLoadContext.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6e651-180">允许对象在被“垃圾回收”之前尝试释放资源并执行其他清理操作。</span><span class="sxs-lookup"><span data-stu-id="6e651-180">Allows the object to try to free resources and perform other cleanup operations before it's reclaimed by garbage collection.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyPath As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="6e651-181">程序集的路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-181">The path to the assembly.</span></span></param>
        <summary><span data-ttu-id="6e651-182">获取 <see cref="T:System.Reflection.AssemblyName" /> 的程序集路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-182">Gets an <see cref="T:System.Reflection.AssemblyName" /> for an assembly path.</span></span></summary>
        <returns><span data-ttu-id="6e651-183">一个对象，该对象包含 <paramref name="assemblyPath" /> 处的程序集的完全解析的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6e651-183">An object that contains the fully parsed assembly name for the assembly at <paramref name="assemblyPath" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e651-184"><paramref name="assemblyPath" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-184"><paramref name="assemblyPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6e651-185">找不到该程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-185">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6e651-186">该程序集不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-186">The assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext GetLoadContext (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Loader.AssemblyLoadContext GetLoadContext(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext ^ GetLoadContext(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetLoadContext : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.GetLoadContext assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="6e651-187">程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-187">An assembly.</span></span></param>
        <summary><span data-ttu-id="6e651-188">获取包含指定 <see cref="T:System.Reflection.Assembly" /> 的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-188">Gets the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> containing the specified <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="6e651-189">包含 <paramref name="assembly" /> 的程序集加载上下文。</span><span class="sxs-lookup"><span data-stu-id="6e651-189">The assembly load context containing the <paramref name="assembly" />.</span></span> <span data-ttu-id="6e651-190">如果在运行时未提供 <paramref name="assembly" />，此方法会返回 NULL。</span><span class="sxs-lookup"><span data-stu-id="6e651-190">If the <paramref name="assembly" /> is not provided by the runtime, this method returns null.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e651-191"><paramref name="assembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-191"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e651-192">获取一个值，该值指示此 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 是否可回收。</span><span class="sxs-lookup"><span data-stu-id="6e651-192">Gets a value that indicates whether this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible.</span></span></summary>
        <value><span data-ttu-id="6e651-193">如果此 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 为可回收，则为 <see langword="true" />;否则，<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-193"><see langword="true" /> if this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="6e651-194">如果未在构造函数中指定值，则该值 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-194">If a value is not specified in the constructor, the value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="6e651-195">有关详细信息，请参阅[如何在 .NET Core 中使用和调试程序集可卸载性](~/docs/standard/assembly/unloadability.md)。</span><span class="sxs-lookup"><span data-stu-id="6e651-195">For more information, see [How to use and debug assembly unloadability in .NET Core](~/docs/standard/assembly/unloadability.md).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6e651-196">描述要加载的程序集的对象。</span><span class="sxs-lookup"><span data-stu-id="6e651-196">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="6e651-197">当在派生类中重写时，允许根据其 <see cref="T:System.Reflection.AssemblyName" /> 解析和加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-197">When overridden in a derived class, allows an assembly to be resolved and loaded based on its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="6e651-198">已加载程序集或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-198">The loaded assembly, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks
 <span data-ttu-id="6e651-199">在程序集解析过程中，<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> 方法具有将程序集名称解析为加载的程序集的第一种机会。</span><span class="sxs-lookup"><span data-stu-id="6e651-199">During assembly resolution, the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> method has the first chance to resolve the assembly name to a loaded assembly.</span></span> <span data-ttu-id="6e651-200">它可以加载程序集或返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="6e651-200">It can either load an assembly or return `null`.</span></span> <span data-ttu-id="6e651-201">如果它返回 `null`，则解决过程将继续。</span><span class="sxs-lookup"><span data-stu-id="6e651-201">If it returns `null`, the resolution process continues.</span></span> <span data-ttu-id="6e651-202">有关完整过程的说明，请参阅 <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)>。</span><span class="sxs-lookup"><span data-stu-id="6e651-202">See <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> for the full process description.</span></span>
 
 > [!IMPORTANT]
 > <span data-ttu-id="6e651-203">若要阻止递归堆栈溢出，请不要从此方法中调用此实例的 <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> 方法。</span><span class="sxs-lookup"><span data-stu-id="6e651-203">To prevent recursive stack overflow, do not call this instance's <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> method from this method.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6e651-204">描述要加载的程序集的对象。</span><span class="sxs-lookup"><span data-stu-id="6e651-204">The object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="6e651-205">根据 <see cref="T:System.Reflection.AssemblyName" /> 解析并加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-205">Resolves and loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="6e651-206">已加载程序集或引发事件。</span><span class="sxs-lookup"><span data-stu-id="6e651-206">The loaded assembly, or throws.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="6e651-207"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> 通过解析 <xref:System.Reflection.AssemblyName>来加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-207"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> loads an assembly by resolving the <xref:System.Reflection.AssemblyName>.</span></span> <span data-ttu-id="6e651-208">这会触发完全解决。</span><span class="sxs-lookup"><span data-stu-id="6e651-208">This triggers a full resolution.</span></span> <span data-ttu-id="6e651-209">解析回退顺序遵循以下过程：</span><span class="sxs-lookup"><span data-stu-id="6e651-209">The resolution fallback sequence follows this process:</span></span>

1. <span data-ttu-id="6e651-210">方法调用 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>。</span><span class="sxs-lookup"><span data-stu-id="6e651-210">The method calls <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="6e651-211"><xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> 不得调用此方法以防止递归堆栈溢出。</span><span class="sxs-lookup"><span data-stu-id="6e651-211"><xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> must not call this method to prevent recursive stack overflow.</span></span>

2. <span data-ttu-id="6e651-212">除非加载了程序集或引发了异常，否则该方法将尝试加载默认 <xref:System.Runtime.Loader.AssemblyLoadContext> 中的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-212">Unless the assembly is loaded or an exception is thrown, the method attempts to load the assembly in the default <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span>
3. <span data-ttu-id="6e651-213">除非加载了程序集或引发了异常，否则方法会激发 <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> 事件。</span><span class="sxs-lookup"><span data-stu-id="6e651-213">Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.</span></span>
4. <span data-ttu-id="6e651-214">除非加载了程序集或引发了异常，否则方法会激发 <xref:System.AppDomain.AssemblyResolve> 事件。</span><span class="sxs-lookup"><span data-stu-id="6e651-214">Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.AppDomain.AssemblyResolve> event.</span></span>
 
> [!NOTE]
> <span data-ttu-id="6e651-215">如果 `assemblyRef` 指定完整的程序集名称，并且与该简单名称匹配的第一个程序集具有不兼容的版本或区域性，则会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="6e651-215"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a incompatible version or culture.</span></span> <span data-ttu-id="6e651-216">加载程序不会继续探测与简单名称匹配的其他程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-216">The loader does not continue probing for other assemblies that match the simple name.</span></span>
 
<span data-ttu-id="6e651-217">每个 <xref:System.Runtime.Loader.AssemblyLoadContext> 只能加载：</span><span class="sxs-lookup"><span data-stu-id="6e651-217">Each <xref:System.Runtime.Loader.AssemblyLoadContext> can load only:</span></span>
 
* <span data-ttu-id="6e651-218">可执行程序集的一个版本。</span><span class="sxs-lookup"><span data-stu-id="6e651-218">One version of an executable assembly.</span></span>
* <span data-ttu-id="6e651-219">每个区域性的附属程序集的一个版本。</span><span class="sxs-lookup"><span data-stu-id="6e651-219">One version of a satellite assembly for each culture.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e651-220"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-220"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6e651-221"><paramref name="assemblyName" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6e651-221"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6e651-222"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-222"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6e651-223">加载了与 <paramref name="assemblyName" /> 不匹配的程序集或模块。</span><span class="sxs-lookup"><span data-stu-id="6e651-223">An assembly or module was loaded which did not match the <paramref name="assemblyName" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="6e651-224">要加载的文件的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-224">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="6e651-225">加载指定路径上的程序集文件的内容。</span><span class="sxs-lookup"><span data-stu-id="6e651-225">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="6e651-226">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-226">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6e651-227"><paramref name="assemblyPath" /> 参数不是绝对路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-227">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e651-228"><paramref name="assemblyPath" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-228">The <paramref name="assemblyPath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6e651-229">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="6e651-229">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6e651-230"><paramref name="assemblyPath" /> 参数为空字符串 ("") 或不存在。</span><span class="sxs-lookup"><span data-stu-id="6e651-230">The <paramref name="assemblyPath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6e651-231"><paramref name="assemblyPath" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-231"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromNativeImagePath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromNativeImagePath (string nativeImagePath, string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromNativeImagePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromNativeImagePath (nativeImagePath As String, assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromNativeImagePath(System::String ^ nativeImagePath, System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromNativeImagePath : string * string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromNativeImagePath (nativeImagePath, assemblyPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeImagePath" Type="System.String" />
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nativeImagePath"><span data-ttu-id="6e651-232">要加载的文件的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-232">The fully qualified path of the file to load.</span></span></param>
        <param name="assemblyPath"><span data-ttu-id="6e651-233">要加载的文件的 IL 版本的完全限定路径，或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-233">The fully qualified path of the IL version of the file to load, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="6e651-234">在指定路径上加载托管程序集文件的本机映像的内容。</span><span class="sxs-lookup"><span data-stu-id="6e651-234">Loads the contents of the native image of a managed assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="6e651-235">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-235">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="6e651-236">托管程序集的本机映像是预实时编译的，以优化在特定平台上运行的。</span><span class="sxs-lookup"><span data-stu-id="6e651-236">The native image of a managed assembly is pre-jitted to optimize running on a specific platform.</span></span>
 
 <span data-ttu-id="6e651-237">程序集路径引用程序集的 IL 版本的路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-237">The assembly path refers to the path to the IL version of the assembly.</span></span> <span data-ttu-id="6e651-238">这是一个可选参数，因为 IL 通常包含在本机映像中。</span><span class="sxs-lookup"><span data-stu-id="6e651-238">It is an optional argument as the IL is typically included in the native image.</span></span> <span data-ttu-id="6e651-239">如果找不到本机映像，则运行时可以将其用作回退。</span><span class="sxs-lookup"><span data-stu-id="6e651-239">It can be used by the runtime as a fallback if the native image is not found.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6e651-240"><paramref name="nativeImagePath" /> 参数不是绝对路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-240">The <paramref name="nativeImagePath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6e651-241"><paramref name="assemblyPath" /> 参数不是绝对路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-241">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e651-242"><paramref name="nativeImagePath" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-242">The <paramref name="nativeImagePath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6e651-243">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="6e651-243">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6e651-244"><paramref name="nativeImagePath" /> 参数为空字符串 ("") 或不存在。</span><span class="sxs-lookup"><span data-stu-id="6e651-244">The <paramref name="nativeImagePath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6e651-245"><paramref name="assemblyPath" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-245"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="6e651-246">字节数组，它是包含托管程序集的基于 COFF 的映像。</span><span class="sxs-lookup"><span data-stu-id="6e651-246">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <summary><span data-ttu-id="6e651-247">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含托管程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-247">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly.</span></span></summary>
        <returns><span data-ttu-id="6e651-248">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-248">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e651-249"><paramref name="assembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-249"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6e651-250"><paramref name="assembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-250"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly, System.IO.Stream assemblySymbols);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly, class System.IO.Stream assemblySymbols) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly, System::IO::Stream ^ assemblySymbols);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream * System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream (assembly, assemblySymbols)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
        <Parameter Name="assemblySymbols" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="6e651-251">字节数组，它是包含托管程序集的基于 COFF 的映像。</span><span class="sxs-lookup"><span data-stu-id="6e651-251">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <param name="assemblySymbols"><span data-ttu-id="6e651-252">包含表示程序集符号的原始字节的字节数组。</span><span class="sxs-lookup"><span data-stu-id="6e651-252">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="6e651-253">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含托管程序集，并且还可以选择包括程序集的符号。</span><span class="sxs-lookup"><span data-stu-id="6e651-253">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly, optionally including symbols for the assembly.</span></span></summary>
        <returns><span data-ttu-id="6e651-254">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-254">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e651-255"><paramref name="assembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-255"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6e651-256"><paramref name="assembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6e651-256"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDll">
      <MemberSignature Language="C#" Value="protected virtual IntPtr LoadUnmanagedDll (string unmanagedDllName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int LoadUnmanagedDll(string unmanagedDllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadUnmanagedDll (unmanagedDllName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr LoadUnmanagedDll(System::String ^ unmanagedDllName);" />
      <MemberSignature Language="F#" Value="abstract member LoadUnmanagedDll : string -&gt; nativeint&#xA;override this.LoadUnmanagedDll : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDll unmanagedDllName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllName"><span data-ttu-id="6e651-257">非托管库的名称。</span><span class="sxs-lookup"><span data-stu-id="6e651-257">Name of the unmanaged library.</span></span> <span data-ttu-id="6e651-258">这通常是不带路径或扩展名的文件名。</span><span class="sxs-lookup"><span data-stu-id="6e651-258">Typically this is the filename without its path or extensions.</span></span></param>
        <summary><span data-ttu-id="6e651-259">允许派生的类按名称加载非托管库。</span><span class="sxs-lookup"><span data-stu-id="6e651-259">Allows derived class to load an unmanaged library by name.</span></span></summary>
        <returns><span data-ttu-id="6e651-260">已加载库的句柄或为 <see cref="F:System.IntPtr.Zero" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-260">A handle to the loaded library, or <see cref="F:System.IntPtr.Zero" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="6e651-261">默认实现始终返回 <xref:System.IntPtr.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6e651-261">The default implementation always returns <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6e651-262">返回 <xref:System.IntPtr.Zero?displayProperty=nameWithType> 时，运行时将加载库及其默认策略。</span><span class="sxs-lookup"><span data-stu-id="6e651-262">When <xref:System.IntPtr.Zero?displayProperty=nameWithType> is returned, the runtime loads the library with its default policy.</span></span>
 
 <span data-ttu-id="6e651-263">可以重写此虚方法以自定义非托管库搜索算法。</span><span class="sxs-lookup"><span data-stu-id="6e651-263">This virtual method can be overridden to customize the unmanaged library search algorithm.</span></span> <span data-ttu-id="6e651-264">重写时，该名称可用于标识库。</span><span class="sxs-lookup"><span data-stu-id="6e651-264">When overridden the name can be used to identify the library.</span></span> <span data-ttu-id="6e651-265">加载的库不需要匹配请求的名称，但可以根据需要进行转换。</span><span class="sxs-lookup"><span data-stu-id="6e651-265">The loaded library does not need to match the requested name, but can be transformed as needed.</span></span> <span data-ttu-id="6e651-266">这可能包括调整平台特定命名的名称。</span><span class="sxs-lookup"><span data-stu-id="6e651-266">This could include adjusting the name for platform specific naming.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDllFromPath">
      <MemberSignature Language="C#" Value="protected IntPtr LoadUnmanagedDllFromPath (string unmanagedDllPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance native int LoadUnmanagedDllFromPath(string unmanagedDllPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDllFromPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function LoadUnmanagedDllFromPath (unmanagedDllPath As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IntPtr LoadUnmanagedDllFromPath(System::String ^ unmanagedDllPath);" />
      <MemberSignature Language="F#" Value="member this.LoadUnmanagedDllFromPath : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDllFromPath unmanagedDllPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllPath"><span data-ttu-id="6e651-267">非托管库的路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-267">The path to the unmanaged library.</span></span></param>
        <summary><span data-ttu-id="6e651-268">从指定路径加载非托管库。</span><span class="sxs-lookup"><span data-stu-id="6e651-268">Loads an unmanaged library from the specified path.</span></span></summary>
        <returns><span data-ttu-id="6e651-269">已加载的本机库的 OS 句柄。</span><span class="sxs-lookup"><span data-stu-id="6e651-269">The OS handle for the loaded native library.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6e651-270">此方法返回的 OS 句柄可用于 <xref:System.Runtime.InteropServices.NativeLibrary?displayProperty=nameWithType> 类的方法。</span><span class="sxs-lookup"><span data-stu-id="6e651-270">The OS handle returned by this method can be used with methods of the <xref:System.Runtime.InteropServices.NativeLibrary?displayProperty=nameWithType> class.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e651-271"><paramref name="unmanagedDllPath" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-271"><paramref name="unmanagedDllPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6e651-272"><paramref name="unmanagedDllPath" /> 参数为空或不是绝对路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-272">The <paramref name="unmanagedDllPath" /> argument is empty or not an absolute path.</span></span></exception>
        <exception cref="T:System.DllNotFoundException"><span data-ttu-id="6e651-273">找不到库。</span><span class="sxs-lookup"><span data-stu-id="6e651-273">The library can't be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6e651-274">库无效。</span><span class="sxs-lookup"><span data-stu-id="6e651-274">The library is not valid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e651-275">获取 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 的名称。</span><span class="sxs-lookup"><span data-stu-id="6e651-275">Get the name of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <value><span data-ttu-id="6e651-276"><see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 的名称。</span><span class="sxs-lookup"><span data-stu-id="6e651-276">The name of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span> <span data-ttu-id="6e651-277">其值可为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-277">Its value can be <see langword="null" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolving">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt; Resolving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Runtime.Loader.AssemblyLoadContext, class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; Resolving" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Resolving" />
      <MemberSignature Language="VB.NET" Value="Public Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Runtime::Loader::AssemblyLoadContext ^, System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ Resolving;" />
      <MemberSignature Language="F#" Value="member this.Resolving : Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " Usage="member this.Resolving : System.Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " FrameworkAlternate="netcore-3.0;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e651-278">在尝试加载到此程序集加载上下文时，程序集解析失败时发生。</span><span class="sxs-lookup"><span data-stu-id="6e651-278">Occurs when the resolution of an assembly fails when attempting to load into this assembly load context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="6e651-279">此事件的处理程序负责返回指定的程序集; 如果程序集未被识别，则为返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="6e651-279">It is the responsibility of the handler for this event to return the assembly that is specified, or to return `null` if the assembly is not recognized.</span></span>
 
 > [!IMPORTANT]
 >  <span data-ttu-id="6e651-280">如果为此事件注册了多个事件处理程序，则将按顺序调用事件处理程序，直到事件处理程序返回的值不 `null`。</span><span class="sxs-lookup"><span data-stu-id="6e651-280">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="6e651-281">后续事件处理程序将被忽略。</span><span class="sxs-lookup"><span data-stu-id="6e651-281">Subsequent event handlers are ignored.</span></span>
 
 <span data-ttu-id="6e651-282">有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6e651-282">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>
 
 <span data-ttu-id="6e651-283">值得注意的是，可以在任何 <xref:System.Runtime.Loader.AssemblyLoadContext> （包括默认上下文）上为此事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="6e651-283">It is noteworthy that a handler can be added for this event on any <xref:System.Runtime.Loader.AssemblyLoadContext>, including the default context.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvingUnmanagedDll">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Reflection.Assembly,string,IntPtr&gt; ResolvingUnmanagedDll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Reflection.Assembly, string, native int&gt; ResolvingUnmanagedDll" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.ResolvingUnmanagedDll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolvingUnmanagedDll As Func(Of Assembly, String, IntPtr) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Reflection::Assembly ^, System::String ^, IntPtr&gt; ^ ResolvingUnmanagedDll;" />
      <MemberSignature Language="F#" Value="member this.ResolvingUnmanagedDll : Func&lt;System.Reflection.Assembly, string, nativeint&gt; " Usage="member this.ResolvingUnmanagedDll : System.Func&lt;System.Reflection.Assembly, System.string, System.nativeint&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Reflection.Assembly,System.String,System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e651-284">在解析本机库失败时发生。</span><span class="sxs-lookup"><span data-stu-id="6e651-284">Occurs when the resolution of a native library fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6e651-285">如果无法通过默认解析逻辑解析本机库（包括 <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll%2A>），则会引发此事件。</span><span class="sxs-lookup"><span data-stu-id="6e651-285">This event is raised if the native library cannot be resolved by the default resolution logic (including <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll%2A>).</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProfileOptimizationRoot">
      <MemberSignature Language="C#" Value="public void SetProfileOptimizationRoot (string directoryPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetProfileOptimizationRoot(string directoryPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.SetProfileOptimizationRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetProfileOptimizationRoot (directoryPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetProfileOptimizationRoot(System::String ^ directoryPath);" />
      <MemberSignature Language="F#" Value="member this.SetProfileOptimizationRoot : string -&gt; unit" Usage="assemblyLoadContext.SetProfileOptimizationRoot directoryPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directoryPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directoryPath"><span data-ttu-id="6e651-286">存储优化配置文件的目录的完整路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-286">The full path to the directory where the optimization profiles are stored.</span></span></param>
        <summary><span data-ttu-id="6e651-287">设置用于存储此加载上下文的优化配置文件的根路径。</span><span class="sxs-lookup"><span data-stu-id="6e651-287">Sets the root path where the optimization profiles for this load context are stored.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[ 

## Remarks        

<span data-ttu-id="6e651-288">配置文件优化通过对可能执行的方法进行后台编译，从而提高了多核计算机上加载上下文的启动性能。</span><span class="sxs-lookup"><span data-stu-id="6e651-288">The profile optimization improves the startup performance of the load context on multicore computers by performing background compilation of methods that are likely to be executed, based on profiles created during previous compilations.</span></span> <span data-ttu-id="6e651-289">有关详细信息，请参阅 <xref:System.Runtime.ProfileOptimization>。</span><span class="sxs-lookup"><span data-stu-id="6e651-289">For more information, see <xref:System.Runtime.ProfileOptimization>.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProfileOptimization">
      <MemberSignature Language="C#" Value="public void StartProfileOptimization (string profile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartProfileOptimization(string profile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.StartProfileOptimization(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartProfileOptimization (profile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartProfileOptimization(System::String ^ profile);" />
      <MemberSignature Language="F#" Value="member this.StartProfileOptimization : string -&gt; unit" Usage="assemblyLoadContext.StartProfileOptimization profile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="profile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="profile"><span data-ttu-id="6e651-290">优化配置文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6e651-290">The name of the optimization profile.</span></span></param>
        <summary><span data-ttu-id="6e651-291">启动指定配置文件的配置文件优化。</span><span class="sxs-lookup"><span data-stu-id="6e651-291">Starts the profile optimization for the specified profile.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[ 

## Remarks        

<span data-ttu-id="6e651-292">配置文件优化通过对可能执行的方法进行后台编译，从而提高了多核计算机上加载上下文的启动性能。</span><span class="sxs-lookup"><span data-stu-id="6e651-292">The profile optimization improves the startup performance of the load context on multicore computers by performing background compilation of methods that are likely to be executed, based on profiles created during previous compilations.</span></span> <span data-ttu-id="6e651-293">有关详细信息，请参阅 <xref:System.Runtime.ProfileOptimization>。</span><span class="sxs-lookup"><span data-stu-id="6e651-293">For more information, see <xref:System.Runtime.ProfileOptimization>.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assemblyLoadContext.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6e651-294">返回此加载上下文的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="6e651-294">Returns the string representation of this load context.</span></span></summary>
        <returns><span data-ttu-id="6e651-295">此加载上下文的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="6e651-295">The string representation of this load context.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="assemblyLoadContext.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6e651-296">开始卸载此 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</span><span class="sxs-lookup"><span data-stu-id="6e651-296">Initiates an unload of this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

+ <span data-ttu-id="6e651-297">AssemblyLoadContext 只能在可回收后卸载。</span><span class="sxs-lookup"><span data-stu-id="6e651-297">An AssemblyLoadContext can only be unloaded if it is collectible.</span></span>
+ <span data-ttu-id="6e651-298">卸载将以异步方式进行。</span><span class="sxs-lookup"><span data-stu-id="6e651-298">Unloading will occur asynchronously.</span></span>
+ <span data-ttu-id="6e651-299">当存在对 AssemblyLoadContext 的引用时，将不会进行卸载。</span><span class="sxs-lookup"><span data-stu-id="6e651-299">Unloading will not occur while there are references to the AssemblyLoadContext.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6e651-300">不允许卸载。</span><span class="sxs-lookup"><span data-stu-id="6e651-300">Unloading is not allowed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; Unloading" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloading As Action(Of AssemblyLoadContext) " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Action&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " Usage="member this.Unloading : System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloading As Action(Of AssemblyLoadContext) " FrameworkAlternate="netcore-3.0;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e651-301">卸载 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 时发生。</span><span class="sxs-lookup"><span data-stu-id="6e651-301">Occurs when the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is unloaded.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
